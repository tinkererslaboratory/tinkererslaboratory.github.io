<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>AVR Programming &#8211; Electronics and Robotics Club, IIT Bombay</title>
<meta name="description" content="Microcontrollers are use to control the operations of various devices and machines like Computers, Microwave Ovens, Moblie phones and Automobiles. This tutorial is based on ATMEL’s AVR series of microcontrollers.">
<meta name="keywords" content="">


<!-- Twitter Cards -->
<meta name="twitter:title" content="AVR Programming">
<meta name="twitter:description" content="Microcontrollers are use to control the operations of various devices and machines like Computers, Microwave Ovens, Moblie phones and Automobiles. This tutorial is based on ATMEL’s AVR series of microcontrollers.">



<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://grubdragon.github.io/erciitb/images/sitelogo.png">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="AVR Programming">
<meta property="og:description" content="Microcontrollers are use to control the operations of various devices and machines like Computers, Microwave Ovens, Moblie phones and Automobiles. This tutorial is based on ATMEL’s AVR series of microcontrollers.">
<meta property="og:url" content="https://grubdragon.github.io/erciitb/tutorials/avr/">
<meta property="og:site_name" content="Electronics and Robotics Club, IIT Bombay">





<link rel="canonical" href="https://grubdragon.github.io/erciitb/tutorials/avr/">
<link href="https://grubdragon.github.io/erciitb/feed.xml" type="application/atom+xml" rel="alternate" title="Electronics and Robotics Club, IIT Bombay Feed">
<link href="https://fonts.googleapis.com/css?family=PT+Serif" rel="stylesheet"> 
<link href="https://fonts.googleapis.com/css?family=EB+Garamond" rel="stylesheet"> 

<!-- https://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="https://grubdragon.github.io/erciitb/assets/css/main.css">
<link rel="stylesheet" href="https://grubdragon.github.io/erciitb/assets/css/team.css"> 
<!-- Webfonts -->
<script src="https://use.edgefonts.net/source-sans-pro:n2,i2,n3,i3,n4,i4,n6,i6,n7,i7,n9,i9;source-code-pro:n4,n7;volkhov.js"></script>

<meta http-equiv="cleartype" content="on">

<!-- HTML5 Shiv and Media Query Support -->
<!--[if lt IE 9]>
  <script src="https://grubdragon.github.io/erciitb/assets/js/vendor/html5shiv.min.js"></script>
  <script src="https://grubdragon.github.io/erciitb/assets/js/vendor/respond.min.js"></script>
<![endif]-->

<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

<!-- Modernizr -->
<script src="https://grubdragon.github.io/erciitb/assets/js/vendor/modernizr-2.7.1.custom.min.js"></script>


<!-- MathJax -->
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="https://grubdragon.github.io/erciitb/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="https://grubdragon.github.io/erciitb/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="https://grubdragon.github.io/erciitb/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://grubdragon.github.io/erciitb/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://grubdragon.github.io/erciitb/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://grubdragon.github.io/erciitb/images/apple-touch-icon-144x144-precomposed.png">

<script src="https://grubdragon.github.io/erciitb/assets/js/scrolltop.js"></script>
<link rel="stylesheet" href="https://grubdragon.github.io/erciitb/assets/css/scrolltop.css">
</head>

<body id="post">
<!-- Return to Top -->
<div onClick="scrollback()" id="return-to-top"><i class="fa fa-chevron-up"></i></div>

<div class="navigation-wrapper">
	<nav role="navigation" id="site-nav" class="animated drop">
	    <ul>
      
		    
		    <li><a href="https://grubdragon.github.io/erciitb/" >Home</a></li>
		  
		    
		    <li><a href="https://grubdragon.github.io/erciitb/about/" >About</a></li>
		  
		    
		    <li><a href="https://grubdragon.github.io/erciitb/tutorials/" >Tutorials</a></li>
		  
		    
		    <li><a href="https://grubdragon.github.io/erciitb/blog/" >Blog</a></li>
		  
		    
		    <li><a href="https://grubdragon.github.io/erciitb/search/" >Search</a></li>
		  
		    
		    <li><a href="https://grubdragon.github.io/erciitb/team/" >The Team</a></li>
		  
	    </ul>
	</nav>
</div><!-- /.navigation-wrapper -->

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->

<header class="masthead">
	<div class="wrap">
      
  		<a href="https://grubdragon.github.io/erciitb/" class="site-logo" rel="home" title="Electronics and Robotics Club, IIT Bombay"><img src="https://grubdragon.github.io/erciitb/images/sitelogo.png" width="200" height="200" alt="Electronics and Robotics Club, IIT Bombay logo" class="animated flipInX"></a>
      
      <h1 class="site-title animated pulse"><a href="https://grubdragon.github.io/erciitb/">Electronics and Robotics Club, IIT Bombay</a></h1>
		<h2 class="site-description animated pulse" itemprop="description">A place for tinkerers and the sort!</h2>
	</div>
</header><!-- /.masthead -->

<div class="js-menu-screen menu-screen"></div>

<div id="main" role="main">
  <article class="hentry">
    
    <div class="entry-wrapper">
      <header class="entry-header center">
        
          <h1 class="entry-title pulse">AVR Programming</h1>
        
      </header>
      <footer class="entry-meta">
        
        <!--
        
        -->
        <span class="author vcard">By <span class="fn">Krish Mehta, Pranav Sankhe, Sanket Agrawal</span></span>
        
	
        <span class="entry-date date published"><time datetime="2016-06-05T00:00:00+00:00"><i class="fa fa-calendar-o"></i>&nbsp;<strong>Last Updated:</strong> 2016-06-05</time></span>
        
        <!--
        
        -->
        
        
        

        <!--
        <ul class="entry-tags">
          Tags: 
        </ul>
        -->

      </footer> 
      <div class="entry-content">
        <p><strong>ATMEL’s AVR</strong> Series of Microcontrollers is a very good option for
those who wish to use the microcontrollers to their true potential,
<strong>exploiting every bit of functionality</strong> they can offer. Learning them
requires you to sometimes indulge into the <strong>internal aspects</strong> of
microcontrollers. Registers, Binary Numbers all play a major role in
operating these microcontrollers in their hardcore form. They form the
heart of the Arduino Microcontrollers you might have learned earlier.</p>

<p>The AVR Series has many microcontrollers which vary in their processing
capacity(Speed) and Memory. Throughout this tutorial we shall consider
ATMega16 as our sample.</p>

<p>(ATMega32: 8-bit AVR Processor, 16 kbytes flash memory)</p>

<h1>TABLE OF CONTENTS</h1>

<ul id="markdown-toc">
  <li><a href="#installation" id="markdown-toc-installation">INSTALLATION</a></li>
  <li><a href="#basics-of-avr" id="markdown-toc-basics-of-avr">BASICS OF AVR</a></li>
  <li><a href="#controlling-input-and-output" id="markdown-toc-controlling-input-and-output">CONTROLLING INPUT AND OUTPUT</a></li>
  <li><a href="#bitwise-operations" id="markdown-toc-bitwise-operations">BITWISE OPERATIONS</a></li>
  <li><a href="#timers-and-counters" id="markdown-toc-timers-and-counters">TIMERS AND COUNTERS</a></li>
  <li><a href="#theory-of-interrupts" id="markdown-toc-theory-of-interrupts">THEORY OF INTERRUPTS</a></li>
  <li><a href="#analogue-digital-conversion" id="markdown-toc-analogue-digital-conversion">ANALOGUE-DIGITAL CONVERSION</a></li>
  <li><a href="#pulse-width-modulation" id="markdown-toc-pulse-width-modulation">PULSE WIDTH MODULATION</a></li>
  <li><a href="#interfacing-with-lcd" id="markdown-toc-interfacing-with-lcd">INTERFACING WITH LCD</a></li>
</ul>
<hr />

<h2 id="installation">INSTALLATION</h2>

<p>In order to write the code for AVR, and to burn it to the
microcontroller, we use the software provided by ATMEL: ATMEL Studio.</p>

<p>We also need something that connects the microcontroller and the
computer (by USB). This was very simple in case of Arduino because among
its peripherals, there was an in-built USB slot. Here we will use a
“<strong>Development Board</strong>”.</p>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image29.jpg" alt="image" /></p>

<p>In the picture above, observe 2 main things:</p>

<ol>
  <li><strong>The Programmer</strong>, which is plugged in the computer USB slot: It is
used for the development board-to-USB Slot interface.</li>
  <li><strong>The Development Board:</strong> Provides an interface to connect pins with
Jumpers to further circuitry and with the input of the programmer.</li>
</ol>

<p>After this let us move on to installation of ATMEL Studio.</p>

<h4 id="a-nameatmel-studioadownload-atmel-studio"><a name="atmel-studio"></a>Download Atmel Studio</h4>

<p>Get the software setup here:
<a href="http://www.atmel.com/tools/ATMELSTUDIO.aspx">http://www.atmel.com/tools/ATMELSTUDIO.aspx</a>.</p>

<h4 id="a-namedriversainstall-drivers"><a name="drivers"></a>Install Drivers</h4>

<p>After installing Atmel Studio 7, we need to install Drivers for the
programmer. Refer to the following videos for the procedure.</p>

<p>For setting up <strong>avrdude</strong>: <a href="https://newbiehack.com/MicrocontrollerProgrammingEnvironmentWinAVRInstall.aspx">Microcontroller Programming Environment WinAVR Install</a></p>

<p>And for configuring the <strong>USBasp tool</strong>: <a href="https://newbiehack.com/MicrocontrollersInstallingAtmelStudio6.aspx">Microcontroller Installing Atmel Studio</a></p>

<p>Atmel Studio has the environment for writing and compiling the code for AVR Microcontrollers, but in order to program the microcontroller with a programmer (the chip with an LED at the USB slot in the above picture), we  need to configure the software with a new tool. For this configuration, we must set up <strong>avrdude</strong> (Video 1).</p>

<p>Now, for configuring the <strong>USBasp tool</strong> we need to set certain things since it is different than the normal USBs which we use at the ports. For this we need to configure the new external programming tool as specified in Video 2.</p>

<p>These two steps are very important and it will not be possible to write the code to the AVR Microcontroller properly without getting these configurations right. Refer the given links properly and if you have any doubts you can ask on the <a href="https://gitter.im/elec-club-iitb/avr-arduino">Electronics Club Gitter Rooms</a>.</p>

<h4 id="a-nameinstall-linuxainstallation-for-linux"><a name="install-linux"></a>Installation for Linux</h4>

<p>You need to install three packages, <code class="highlighter-rouge">gcc-avr</code>,<code class="highlighter-rouge">avr-libc</code> and <code class="highlighter-rouge">avrdude</code> for compiling and burning to AVR microcontrollers</p>

<p>On ubuntu you can run the command</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sudo apt-get install gcc-avr avr-libc avrdude
</code></pre>
</div>

<p>After that we have prepared a Makefile to compile and burn AVR code on linux.
You can download the Makefile <a href="https://grubdragon.github.io/erciitb/assets/tutorials/avr/Makefile">here</a>.</p>

<p>Copy this Makefile into your project folder and open it in a text editor. You
need to edit the first line of the file to be <code class="highlighter-rouge">PROJECT = &lt;filename&gt;</code>. For eg.
if the name of your main C file is <code class="highlighter-rouge">test.c</code>, your first line should be</p>

<div class="highlighter-rouge"><pre class="highlight"><code>PROJECT = test
</code></pre>
</div>

<p>Then run</p>

<div class="highlighter-rouge"><pre class="highlight"><code>make
</code></pre>
</div>

<p>to compile the code and generate HEX file. Then run</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sudo make burn
</code></pre>
</div>

<p>to burn HEX file to AVR after connecting USBasp.</p>
<hr />

<h2 id="basics-of-avr">BASICS OF AVR</h2>

<h3 id="pins-a-namepinsa">Pins <a name="pins"></a></h3>

<p>Confronting the Pin Diagram of ATMega16 at this stage can be a little
dangerous for your enthusiasm, so please proceed slowly.</p>

<p>Apart from the Power pins, all the pins on AVR can be configured as
Input or Output. These pins are present in four groups, or “Ports”,
namely PortA, PortB, PortC, PortD. Every pin is given a name, like
PA0,PB5 etc associated with its port. Besides every pin, its special
function is mentioned in brackets. For example, all pins of PORTA can be
used for ADC purpose apart from regular digital input/output. In this
way each pin has a special function. So, we have 8x4=32 normal I/O pins,
and 8 different pins meant for power supply, ADC voltage reference,
reset etc.</p>

<h4 id="pinout-for-atmega16">Pinout for ATmega16</h4>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image20.png" alt="image" /></p>

<h3 id="registers-a-nameregistersa">Registers <a name="registers"></a></h3>

<p>The microcontrollers(uC) use Registers to store the data describing the
state(or mode) of certain operations(in most of our cases). For example,
there is a register to store the “state/mode” of pins in every port,
whether they are input or output pins. The Timer/Counter Control
Registers(TCCR1A/B) store information regarding timers and
counters(certain parameters etc). Similarly, there are many registers
and they store bytes that control most of the functions of the
microcontroller, so, the High/Low states of bits of those registers
enable/disable interrupts, ADC etc.</p>

<p>The first register we will see is the one I just described. It is called
the Data Direction Register(DDR). Hence DDRA is the register(8-bits of
data) showing Input/output states of the 8 pins in port A.</p>

<h3 id="using-the-datasheet-a-namedatasheeta">Using the Datasheet <a name="datasheet"></a></h3>

<p>Though very intimidating to look at, the datasheet can provide you with
just the right information if you know how to use it, and if you know
that you have to use ‘IT’.</p>

<p>It is not at all necessary to read the complete datasheet, but there are
portions in it which are at our level of understanding and there is also
useful information which we will certainly need on our way.</p>

<p>It contains the code for every register, i.e. which bit of the register
stores data for what function and lot of other information which we will
use.</p>

<p>So keep the datasheet handy!</p>

<p>Get it here:
<a href="http://www.atmel.com/devices/atmega32.aspx?tab=overview">http://www.atmel.com/devices/atmega32.aspx?tab=overview</a>.</p>
<hr />

<h2 id="controlling-input-and-output">CONTROLLING INPUT AND OUTPUT</h2>

<p>As stated earlier, one of the registers called Data Direction Register
is used to control whether the pin acts as an Input pin or an Output
pin.</p>

<p>Thus we have <strong>four</strong> 8-bit registers:</p>

<p><strong>DDRA/B/C/D</strong> for controlling 8 pins each, of <strong>Ports A/B/C/D.</strong></p>

<p>The convention for setting the input/output bit is:</p>

<p><strong>1 - Output pin</strong> i.e. Controlled by Microcontroller</p>

<p><strong>0 - Input pin</strong> i.e. Controlled by external circuit</p>

<h3 id="controlling-the-output-a-namecontrolling-outputa">Controlling the Output <a name="controlling-output"></a></h3>

<p>Now, for the <strong>Output</strong> Pins, in order to set them to the value we wish,
we use another register <strong>PORTA/B/C/D</strong>. Thus <strong>PORTA</strong> is a 8-bit
register, which stores the <strong>8 bits</strong> corresponding to each pin of Port
A(effectively only the Output pins) for whether to give it a <strong>HIGH or
LOW</strong> state.</p>

<p>Let us convey all this through a code snippet.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">DDRA</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b00001101</span><span class="p">;</span>

<span class="n">PORTA</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b00000101</span><span class="p">;</span></code></pre></figure>

<p><strong>Note:</strong> The order of pins is 76543210, i.e. Most Significant Bit
corresponds to pin 7</p>

<p>This tells the microcontroller that:</p>

<ul>
  <li>Line 1: Pins 0,2,3 of Port A should be declared as output pins and rest
as input.</li>
  <li>Line 2: Pins 0,2 should should give HIGH(Vin) and 3 should give LOW(0)
output.</li>
</ul>

<p>The bits corresponding to input pins of present in PORTA don’t matter,
that is PORTA is an Output only Register</p>

<h3 id="reading-the-input-a-namereading-inputa">Reading the input <a name="reading-input"></a></h3>

<p>For the input values, there is a similar Input only Register,
<strong>PINA/B/C/D.</strong></p>

<p>The values of inputs are stored onto this 8-bit register, and in the
code, we use this register with the comparison operator.</p>

<p>This statement:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">PINA</span> <span class="o">==</span> <span class="mi">0</span><span class="n">b11000010</span><span class="p">;</span></code></pre></figure>

<p>Checks if the inputs on pins 7,6,5,4 and 1 are High,High,Low,Low and
High respectively.</p>
<hr />

<h2 id="bitwise-operations">BITWISE OPERATIONS</h2>

<p>Bit masking refers to accessing specific bits in a data and modifying
them according to our needs. Bit operations are a way to implement
masking.</p>

<p>Bitwise Operators available in C are: AND (<code class="highlighter-rouge">&amp;</code>), OR (<code class="highlighter-rouge">|</code>), XOR (<code class="highlighter-rouge">^</code>) and NOT
(<code class="highlighter-rouge">~</code>). There are also bit shift operators viz. Bit left shift (<code class="highlighter-rouge">&lt;&lt;</code>)
and Bit right shift (<code class="highlighter-rouge">&gt;&gt;</code>) operators.</p>

<p>Bitwise operators are the ones that are defined on 2 bits and hold for
large binary number through bit-by-bit binary operations and defined on
2 bits.</p>

<h3 id="boolean-algebra-a-nameboolean-algebraa">Boolean Algebra <a name="boolean-algebra"></a></h3>

<h4 id="and-">AND (<code class="highlighter-rouge">&amp;</code>)</h4>

<p>Works like regular logical AND(A.B). So, for <code class="highlighter-rouge">PORTA = 0b01101111 = 0x6f</code> and <code class="highlighter-rouge">PORTB = 0b10011001 = 0x99</code>,</p>

<div class="highlighter-rouge"><pre class="highlight"><code>PORTA &amp; PORTB = 01101111 &amp; 10011001 = 00001001 = 0x09.
</code></pre>
</div>

<p>OR(<code class="highlighter-rouge">|</code>), XOR(<code class="highlighter-rouge">^</code>), NOT(<code class="highlighter-rouge">~</code>) work in the same way. They are same as their
logical functions for 2 bit operations, and for larger numbers(many
bits) they are executed bit by bit using binary model for each bit
pair(as shown in bitwise AND example).</p>

<h3 id="bit-shifting-a-nameshiftinga">Bit Shifting <a name="shifting"></a></h3>

<p>As the name suggests these operation are used to shift the position of a
bit by some particular places. If you use <code class="highlighter-rouge">&lt;&lt;</code> then the bits are
shifted to the left, and if you use <code class="highlighter-rouge">&gt;&gt;</code> then the bits are shifted
to the right and the bits are shifted by the number of places return
besides these symbols.</p>

<h4 id="binary-left-shift-operator">Binary Left Shift Operator</h4>

<p>This shifts left operand value to left by number of bits specified in
the right operand. In other words, Binary left shift moves bits to a
specified number of places to the left. The least significant bit is
appended with 0 and most significant bit is dropped. The value of the
variable gets multiplied by 2 for every left shift that occurs.</p>

<p>If <code class="highlighter-rouge">PORTA=01101111</code>,</p>

<p>Then <code class="highlighter-rouge">PORTA &lt;&lt; 3 = 01111000;</code></p>

<h4 id="binary-right-shift-operator">Binary Right Shift Operator</h4>

<p>This shifts left operand value to right by number of bits specified by
the right operand. The most significant bit is appended with 0 and least
significant bit is dropped.The value of the variable gets divided by 2
for every right shift that occurs.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>PORTA &gt;&gt; 2 = 00011011;
</code></pre>
</div>

<h4 id="usage-in-avr">Usage in AVR</h4>

<p>Bit <strong>Operations</strong> are used very often, wherever the logical operations
are required.</p>

<p>Bit <strong>Shifting</strong> is very useful in setting only specific bits of
registers without worrying about everything else on the register.</p>

<p>If you wanted to turn on the lowest bit on PORTA, then you can simply
write a 1 to PORTA because a 1, in 8 bit binary, is really 00000001.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>PORT A = 1;
</code></pre>
</div>

<p>However, if you wanted to turn on the second lowest bit on PORTA, then
an easy way to do it is with a bit shift:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>PORTA = (0b00000001&lt;&lt;1);
</code></pre>
</div>

<p>Example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>PORTA = 10001001;
</code></pre>
</div>

<p>Means the same as</p>

<div class="highlighter-rouge"><pre class="highlight"><code>PORTA= (1&lt;&lt;7) | (1&lt;&lt;4)| (1&lt;&lt;0)
</code></pre>
</div>

<h3 id="bit-masking-a-namemaskinga">Bit Masking <a name="masking"></a></h3>

<p>Bits in registers are given names. We will discuss TCCR1B
later here, but for the time being assume that a register has a bit
named CS10. The usefulness comes out of the fact that you can set the
CS10 bit High just by executing:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>TCCR1B = (1&lt;&lt;CS10);
</code></pre>
</div>

<p>That is, “CS10” acts as its numeric location on the register!
Bit <strong>Masking</strong> is used to carry out operations on only specific bits
from a number of many bits.</p>

<p>Instead of <code class="highlighter-rouge">TCCR1B = 1&lt;&lt;CS10 | 1&lt;&lt;CS11</code>,
It is better to write: <code class="highlighter-rouge">TCCR1B |= 1&lt;&lt;CS10 | 1&lt;&lt;CS11</code>.
It lets the other bits stay as they are(OR with 0) and only sets the
selected bits high(from low).</p>
<hr />

<h2 id="timers-and-counters">TIMERS AND COUNTERS</h2>

<p>The operations in any microcontroller are “<strong>sequential</strong>” at heart, and
so they all rely on clock-pulses. Hence the microcontrollers have
<strong>internal clocks</strong> that keep ticking at the given rate, irrespective of
anything else happening around them. They can also use <strong>external</strong>
clocks for this same purpose.</p>

<p>The timer and counter functions in the microcontroller simply <strong>count in
sync</strong> with the microcontroller clock. But the counter has limitations
due to its bit-capacity, i.e. a 8-bit counter can count only up to
256(or 0 to 255). So generally there is a 16-bit counter(65536 counts).
The counts are stored in the most important Timer/Counter Register,
<code class="highlighter-rouge">TCNT1</code>(16-bit, by default).</p>

<h3 id="pre-scaling-a-namepre-scalinga">Pre-scaling <a name="pre-scaling"></a></h3>

<p>Now compare the maximum count of a counter and the clock-ticks of a
microcontroller. Standard AVR Microcontrollers generally operate at 1
Mhz, that is 1,000,000 ticks per second, which is much more than 65536!</p>

<p>Hence, we need “prescaling” to increase the time-range of one cycle of
the counter(they start all over again after attaining the max value) to
a time comparable to our physical time domain(seconds). Prescaling is a
way for the counter to <strong>skip some clock ticks</strong>.</p>

<p>AVR Microcontrollers allow prescaling of: 8, 64, 256 and 1024.</p>

<p>So, by setting a “Prescaler” of 8, the counter counts only once for
every 8 ticks of the microcontroller clock, i.e. it runs at <code class="highlighter-rouge">F_CPU/8</code>
(<code class="highlighter-rouge">F_CPU</code> = Frequency of uC).</p>

<h3 id="registers-for-controlling-timerscounters-a-nametimer-registersa">Registers for controlling timers/counters <a name="timer-registers"></a></h3>

<p>The register <code class="highlighter-rouge">TCCR1A</code> and <code class="highlighter-rouge">TCCR1B</code> (Timer/Counter Control Registers) are used
for this. Please refer the datasheet for the description of the
registers.</p>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image21.png" alt="image" /></p>

<p>As you can see, all the 8-bits in the register are named.</p>

<p>(No need of knowing the function of all the 8 bits at this stage, the
relevant ones will be discussed next)</p>

<p>Let us understand this through our first code on ATMEL Studio.</p>

<h3 id="first-code-led-blink-a-nameled-blinka">First code: LED Blink <a name="led-blink"></a></h3>

<p>Using the concepts learnt till now, we will write a program to toggle an
LED 7 times a second.</p>

<p>We will proceed in a way in which you will have to, when you are doing
it yourself. That is, we will use the Datasheet for reference instead of
direct steps given to you.</p>

<h4 id="how-to-choose-the-correct-prescaler">How to choose the correct prescaler?</h4>

<p>The uC ticks 1,000,000 times a second. We want to toggle the LED 7 times
a second. So, we want the LED to toggle on every 142857th clock pulse.
Now, since 65536 (highest value of count) is smaller than 142857, we want
to set a prescaler such that “the highest count comes well after the
time when the original uC clock reaches 142857” (Read this line twice
:p). 8, 64 are suitable prescalers. Let us take 64.</p>

<h4 id="okay-i-got-the-prescaler-now-how-do-i-set-that">Okay. I got the prescaler. Now how do I set that?</h4>

<p>Search “prescaler” and after some experience you will know where to
look, among the numerous results you get for “prescaler” :p.</p>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image31.png" alt="image" /></p>

<p>In the relevant table you will find the bit combination of <code class="highlighter-rouge">CS12</code>/<code class="highlighter-rouge">11</code>/<code class="highlighter-rouge">10</code>
required to set the prescaler we want. In our case: <code class="highlighter-rouge">CS12</code>/<code class="highlighter-rouge">11</code>/<code class="highlighter-rouge">10</code>=<code class="highlighter-rouge">0</code>/<code class="highlighter-rouge">1</code>/<code class="highlighter-rouge">1</code>
respectively. So we set the bits accordingly, using concepts of bit
shifting and bit masking as discussed earlier.</p>

<p>(I told you about <code class="highlighter-rouge">TCCR1A</code>/<code class="highlighter-rouge">B</code> earlier, but ideally you first discover
<code class="highlighter-rouge">CS12</code>/<code class="highlighter-rouge">11</code>/<code class="highlighter-rouge">10</code> and then find out that these bits are present on <code class="highlighter-rouge">TCCR1B</code>,
going by the datasheet approach :p)</p>

<h4 id="when-to-toggle-the-led">When to toggle the LED?</h4>

<p>On every 142857th pulse of the uC clock. That is, when <code class="highlighter-rouge">TCNT1</code> is at the
142857/64 = 2232<sup>th</sup> count (for prescaler=64).</p>

<p>After this background have a look at the actual code required for this.</p>

<h4 id="code">Code</h4>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include&lt;avr/io.h&gt;;
</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>

    <span class="n">DDRB</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b00000001</span><span class="p">;</span> <span class="c1">//Pin B0 becomes output pin
</span>
    <span class="n">PORTB</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b00000000</span><span class="p">;</span> <span class="c1">//set B0 to Low
</span>
    <span class="n">TCCR1B</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">CS10</span> <span class="o">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">CS11</span><span class="p">;</span> <span class="c1">//set Prescaler
</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">TCNT1</span><span class="o">&gt;</span><span class="mi">2232</span><span class="p">){</span> <span class="c1">//2232=65536/7
</span>
            <span class="n">TCNT1</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="c1">//reset counter
</span>
            <span class="n">PORTB</span> <span class="o">^=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">PINB0</span><span class="p">;</span> <span class="c1">//toggle LED
</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<hr />

<h2 id="theory-of-interrupts">THEORY OF INTERRUPTS</h2>

<p>Interrupts are events that have the highest priority for the
microcontroller(it pays immediate attention to them). That is, when an
interrupt event occurs, the microcontroller Pauses its current task and
attends to the interrupt. This is done by executing a routine called
<strong>Interrupt Service Routine(ISR).</strong> At the end of the ISR, the
microcontroller returns to the task it had paused and continues
normally. So ISR or Interrupt Handler is the piece of code that must be
executed when an interrupt is triggered.</p>

<p>Now, for enabling the execution of interrupts, we need to give
appropriate values to certain bits, in certain specific registers. One
compulsory bit is the <strong>Global Interrupt Enable bit</strong>. That is, when an
interrupt flag is raised, the global interrupt bit must be High, in
order to forward that interrupt request. So it is like an And-filter:
“<strong>Request</strong> an interrupt if that specific <strong>interrupt flag</strong> is raised
<strong>AND</strong> the <strong>global interrupt</strong> is enabled.”</p>

<blockquote>
  <p>A “flag” is like the abstract-physical representation of a bit for an
event :p</p>
</blockquote>

<p>Apart from the global interrupt enable bit, we have interrupt enabling
bits for all the ways in which interrupts can be triggered. They can be
triggered through the following ways:</p>

<ul>
  <li>ADC</li>
  <li>Timer matching a given count</li>
  <li>Pin being High/Low</li>
  <li>Serial Communication</li>
</ul>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image33.jpg" alt="image" /></p>

<h3 id="timer-triggered-interrupt-a-nametimer-interrupta">Timer triggered interrupt <a name="timer-interrupt"></a></h3>

<p>Now let us apply our theory in writing a code for triggering an
interrupt when the timer reaches a certain count.</p>

<p>We still need to know about the specific bits to be set for triggering
an interrupt by comparison with timer. This is done by <strong>Clear Timer on
Compare Mode</strong>.</p>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image15.png" alt="image" /></p>

<p>See option 4. This mode clears(resets) the timer on matching with a
given value.</p>

<p>We also need to enable the time-match-triggered interrupt.</p>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image08.png" alt="image" /></p>

<p>We will set <code class="highlighter-rouge">OCIE1A</code> bit High, thus enabling it. So, when the <strong>timer
reaches the value</strong> specified(stored) in <code class="highlighter-rouge">OCR1A</code>, timer will be
<strong>cleared</strong> (“Clear on Compare”) and the Output Compare Match Interrupt
Enable becomes high (Interrupt flag raised).</p>

<p>Once the and interrupt is requested(global interrupt must be enabled),
uC will go into the ISR, so we will specify the code for the ISR also.</p>

<h4 id="code-1">Code</h4>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include&lt;avr/io.h&gt;
</span>
<span class="cp">#include&lt;avr/interrupt.h&gt;
</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">sei</span><span class="p">();</span> <span class="c1">//enable global interrupt
</span>
    <span class="n">DDRB</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">PINB0</span><span class="p">;</span>
    <span class="n">TCCR1B</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">CS10</span> <span class="o">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">CS11</span> <span class="o">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">WGM12</span><span class="p">;</span> <span class="c1">//set prescaler, and enable CTC
</span>
    <span class="n">TIMSK</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">OCIE1A</span><span class="p">;</span> <span class="c1">//Timer1 Output Compare A Match interrupt enabled
</span>
    <span class="n">OCR1A</span> <span class="o">=</span> <span class="mi">15624</span><span class="p">;</span> <span class="c1">//Value at which CTC
</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){}</span>
<span class="p">}</span>

<span class="n">ISR</span><span class="p">(</span><span class="n">TIMER1_COMPA_vect</span><span class="p">){</span> <span class="c1">//Checks argument
</span>
    <span class="n">PORTB</span> <span class="o">^=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">PINB0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<hr />

<h2 id="analogue-digital-conversion">ANALOGUE-DIGITAL CONVERSION</h2>

<p>Microcontrollers are capable of detecting binary signals i.e is the
button pressed or not?.</p>

<p>It interprets five volts as 1 and zero volts as 0. The world however is
not so simple and likes to use shades of gray. What if the signal is
2.72V? A 5V analog sensor may output 0.01V or 4.99V or anything
inbetween. Microcontrollers have a device built into them that allows us
to convert these voltages into values that we can use in a program to
make a decision.</p>

<p>The ADC reports a <strong>ratiometric value</strong>. This means that if the ADC is
a 10 bit ADC then it assumes 5V is 1023 and anything less than 5V will
be a ratio between 5V and 1023. Hence we can see analog to digital
conversions are dependant on the the reference voltage(which is by
default the system voltage).</p>

<p>In microcontrollers we have the flexibility of setting the reference
analog voltage for the ADC.There’s a pin available on the
microcontroller called as <code class="highlighter-rouge">AREF</code> which can be set to desired values
and you can have your customized ADC. For example in a 10 bit ADC if the
input voltage is equal to<code class="highlighter-rouge">AREF</code>then the ADC output is 1023. If the input
voltage is less than<code class="highlighter-rouge">AREF</code>voltage then the ADC output is somewhere
between 0 - 1023.</p>

<p>As you know, we need to set certain bits in some registers in order to
use ADC.</p>

<ul>
  <li><strong>ADC Multiplexer Selection Register (<code class="highlighter-rouge">ADMUX</code>):</strong> For selecting the
reference voltage and the input channel.</li>
  <li><strong>ADC Control and Status Register A (<code class="highlighter-rouge">ADCSRA</code>):</strong> As the name says it has
the status of ADC and is also used for controlling it.</li>
  <li><strong>ADC Data Register (<code class="highlighter-rouge">ADCL</code> and <code class="highlighter-rouge">ADCH</code>):</strong> The final result of conversion is
here.</li>
</ul>

<p>Here’s the logic flow for algorithm for using ADC:</p>

<ul>
  <li>Enable global interrupts</li>
  <li>Selecting the correct clock frequency for maximum resolution ( 50 – 200
KHz)</li>
  <li>Selecting the input pin</li>
  <li>Set the ADC Interrupt Enable</li>
  <li>Enabling the ADC</li>
  <li>Start the ADC conversion</li>
</ul>

<p>The descriptions of these registers, and the relevant tables for
deciding the bit combinations as given in the datasheet are shown below.</p>

<p>Based on the tables that follow, which bits are set to what value for
achieving what setting is mentioned in the code comments.</p>

<h4 id="adscra">ADSCRA</h4>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image12.png" alt="image" /></p>

<h4 id="admux">ADMUX</h4>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image24.png" alt="image" /></p>

<h4 id="selecting-input-pin">Selecting Input Pin</h4>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image10.png" alt="image" /></p>

<h4 id="setting-adc-prescaler">Setting ADC Prescaler</h4>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image11.png" alt="image" /></p>

<h4 id="reference-voltage-selection">Reference Voltage Selection</h4>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image13.png" alt="image" /></p>

<h4 id="registers-for-storing-the-digital-output-available-in-two-formats">Registers for storing the digital output (available in two formats)</h4>

<p>The result, which is a 10-bit number is stored here, and thus 8 bits
together and two bits after/before the 8
bits (<code class="highlighter-rouge">ADLAR</code>=<code class="highlighter-rouge">0</code>/<code class="highlighter-rouge">1</code>).</p>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image34.png" alt="image" /></p>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image25.png" alt="image" /></p>

<h3 id="code-2">Code</h3>

<h4 id="for-adlar0">For <code class="highlighter-rouge">ADLAR=0</code></h4>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;avr/io.h&gt;
</span>
<span class="cp">#include &lt;avr/interrupt.h&gt;
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ADCSRA</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">ADPS2</span><span class="p">;</span> <span class="c1">//ADC Prescaler = 16
</span>
    <span class="n">ADMUX</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">REFS0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">REFS1</span><span class="p">);</span> <span class="c1">// Reference Voltage = 2.56V
</span>
    <span class="n">ADCSRA</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">ADIE</span><span class="p">;</span> <span class="c1">// Enable ADC Interrupt
</span>
    <span class="n">ADCSRA</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">ADEN</span><span class="p">;</span> <span class="c1">//Enable ADC
</span>
    <span class="n">sei</span><span class="p">();</span>
    <span class="n">ADCSRA</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">ADSC</span><span class="p">;</span> <span class="c1">//Start Conversion
</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">){};</span>
<span class="p">}</span>

<span class="n">ISR</span><span class="p">(</span><span class="n">ADC_vect</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">low_1</span> <span class="o">=</span> <span class="n">ADCL</span><span class="p">;</span> <span class="c1">//a datatype of 8 bits, unsigned
</span>
    <span class="kt">uint16_t</span> <span class="n">output_ans</span> <span class="o">=</span> <span class="n">ADCH</span><span class="o">&lt;&lt;</span><span class="mi">8</span> <span class="o">|</span> <span class="n">low_1</span><span class="p">;</span> <span class="c1">//similar, but 16 bits, concatenated with upper two bits in ADLAR
</span>
    <span class="n">ADCSRA</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">ADSC</span><span class="p">;</span><span class="err"> </span><span class="c1">//Start again
</span>
<span class="p">}</span></code></pre></figure>

<h4 id="for-adlar1">For <code class="highlighter-rouge">ADLAR=1</code></h4>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;avr/io.h&gt;
</span>
<span class="cp">#include &lt;avr/interrupt.h&gt;
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ADCSRA</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">ADPS2</span><span class="p">;</span>
    <span class="n">ADMUX</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">REFS0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">REFS1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span> <span class="mi">1</span><span class="o">&lt;&lt;</span> <span class="n">ADLAR</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">//ADLAR=1 this time
</span>
    <span class="n">ADCSRA</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">ADIE</span><span class="p">;</span>
    <span class="n">ADCSRA</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">ADEN</span><span class="p">;</span>

    <span class="n">sei</span><span class="p">(</span> <span class="p">);</span>
    <span class="n">ADCSRA</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">ADSC</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">){}</span>
<span class="p">}</span>

<span class="n">ISR</span><span class="p">(</span><span class="n">ADC_vect</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">low_1</span> <span class="o">=</span> <span class="n">ADCL</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">output_ans</span> <span class="o">=</span> <span class="n">ADCH</span><span class="o">&lt;&lt;</span><span class="mi">2</span> <span class="o">|</span> <span class="n">low_1</span><span class="o">&gt;&gt;</span><span class="mi">6</span><span class="p">;</span> <span class="c1">//merging is slightly different
</span>
    <span class="n">ADCSRA</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">ADSC</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<hr />

<h2 id="pulse-width-modulation">PULSE WIDTH MODULATION</h2>

<p>As you might know, PWM is a technique to produce Analog-looking output
by digital means. We discussed the same in our Arduino Tutorial(LINK
HERE), and you can refer the theory of PWM here:
<a href="https://www.arduino.cc/en/Tutorial/PWM">https://www.arduino.cc/en/Tutorial/PWM</a>.</p>

<p>Its main use is to control the power supplied to inertial loads like
motors. An average value of current/voltage is supplied to the load by
turning the switch on off very fast, at a particular frequency.</p>

<p>While in arduino, we had the ready-made command <code class="highlighter-rouge">analogWrite()</code> for this,
here we will have to engineer the whole procedure :p.</p>

<p>We need to the following things in order to execute PWM in AVR:</p>

<ol>
  <li>Know the PWM Enabled pins.</li>
  <li>Calculate the duty cycle, hence the time(within one cycle) when to
turn the switch on/off.</li>
  <li>Set the correct bits(High/Low) for enabling PWM in
the microcontroller.</li>
</ol>

<p>Use the Datasheet to find various Modes in which we can use PWM(Waveform
Generator). We will use the <strong>Fast PWM Mode</strong>, with <code class="highlighter-rouge">ICR1</code> as Top-most
value.</p>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image35.png" alt="image" /></p>

<p>Another thing to be specified is here:</p>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image09.png" alt="image" /></p>

<p>We will choose the 4th option, i.e. <code class="highlighter-rouge">COM1A1</code> and <code class="highlighter-rouge">COM1A0</code> High, so <code class="highlighter-rouge">OCR1A</code> is
cleared when it reaches our count from reverse(the top). Let us see this
through code:</p>

<h4 id="code-3">Code:</h4>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;avr/io.h&gt;
</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)}{</span>

    <span class="n">DDRD</span> <span class="o">|=</span> <span class="mh">0xFF</span><span class="p">;</span>
    <span class="n">TCCR1A</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">WGM11</span> <span class="o">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">COM1A1</span> <span class="o">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">COM1A0</span><span class="p">;</span>
    <span class="n">TCCR1B</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">WGM13</span> <span class="o">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">WGM12</span> <span class="o">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">CS10</span><span class="p">;</span> 
    <span class="c1">//These two lines enabled Fast PWM, set the inverting mode and gave a prescaler of 1 (no prescaling)
</span>

    <span class="n">ICR1A</span> <span class="o">=</span> <span class="mi">24999</span><span class="p">;</span> 
    <span class="c1">// We assume the frequency we want, and divide it by F_CPU to get the count
</span>
    <span class="c1">// In this case, we have set a frequency of 40 Hz
</span>

    <span class="n">OCR1A</span> <span class="o">=</span> <span class="n">ICR1A</span> <span class="o">-</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// t is the time for which u want the pulse to be high
</span>
    <span class="c1">// We are using the inverted mode, hence we assign from the end
</span>
    <span class="c1">// t can be any value from 1 – 24998 :P
</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">){}</span>
<span class="p">}</span></code></pre></figure>

<p>Here, duty cycle of (t/24999)*100% will be achieved because, in the
<strong>inverting mode</strong> <code class="highlighter-rouge">OC1A</code>/<code class="highlighter-rouge">B</code> is cleared at bottom, and set(High) on match.</p>
<hr />

<h2 id="interfacing-with-lcd">INTERFACING WITH LCD</h2>

<h3 id="anatomy-of-the-lcd-screen-a-namelcd-anatomya">Anatomy of the LCD Screen <a name="lcd-anatomy"></a></h3>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image32.png" alt="image" /></p>

<h3 id="controlling-the-lcd-a-namelcd-controla">Controlling the LCD <a name="lcd-control"></a></h3>

<p>There is an instruction set for the LCD, which specifics the specific
setting of bits <code class="highlighter-rouge">RS</code>, <code class="highlighter-rouge">RW</code> and <code class="highlighter-rouge">DB0</code> to <code class="highlighter-rouge">DB7</code>, for giving specific commands to
the LCD. But that is the internal functioning, we do not need to indulge
into all of this. Instead, we have a header file wherein each
instruction(combination of bits High/Low) is mapped to a function in C.
So we will use this header file: “lcd.h”.</p>

<p>You can understand the functioning of lcd.h by looking at its functions
and looking up the instruction sheet to know what those functions are
implementing.</p>

<p>For now, let us see the code using lcd.h:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;avr/io.h&gt;
</span>
<span class="cp">#include &lt;avr/delay.h&gt;
</span>
<span class="cp">#include "lcd.h"
</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>

    <span class="n">LCD_init</span><span class="p">();</span> <span class="c1">//initialize LCD screen
</span>
    <span class="n">LCD_write</span><span class="p">(</span><span class="s">"Hello AVR"</span><span class="p">);</span> <span class="c1">// You can write strings
</span>
    <span class="n">LCD_putchar</span><span class="p">(</span><span class="s">"!"</span><span class="p">);</span> <span class="c1">// You can also write single characters
</span>
    <span class="n">_delay_ms</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span> <span class="c1">// Display text for 3s
</span>
    <span class="n">LCD_wait</span><span class="p">();</span> <span class="c1">// Waits until any previous command finishes, LCD is free
</span>
    <span class="n">LCD_command</span><span class="p">(</span><span class="mh">0x01</span><span class="p">);</span> <span class="c1">// This is how you send commands
</span>
    <span class="c1">// This command will clear the screen
</span>
    <span class="c1">// Look it up in the Instruction Set
</span>

    <span class="n">LCD_write</span><span class="p">(</span><span class="s">"Elec Club rocks!"</span><span class="p">);</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span></code></pre></figure>

<p>Here, <code class="highlighter-rouge">LCD_init</code> etc are commands of lcd.h which do what is specified in
the comments.</p>

<p>You can also construct your own functions, if you have the knowledge of
instruction set and the functioning of LCD. Let us make a function to
set the cursor to (x,y) of the LCD.</p>

<h4 id="what-we-need-to-know-before-we-can-do-this">What we need to know before we can do this:</h4>

<p><img src="https://grubdragon.github.io/erciitb/assets/tutorials/avr/image30.png" alt="image" /></p>

<p>Each block in the LCD which displays a character is represented by a
DDRAM block. Hence to set the cursor position we need to set the DDRAM
address. This, we look up in the instruction sheet given above.</p>

<p>We need to set <code class="highlighter-rouge">DB7 = 1</code> and <code class="highlighter-rouge">DB6</code>…<code class="highlighter-rouge">DB0</code> to the address we want.</p>

<p>The addresses of 16x2 LCD are 0…15 for the first line and 64…79 for
the second</p>

<p>line. 16 characters per line. So here is the required function:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="n">LCD_cursor_goto</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">addr</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span> <span class="c1">// Set DB7 to 1
</span>
    <span class="k">if</span><span class="p">(</span><span class="n">y</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">;</span> <span class="c1">// Start counting from 64(0x40) for line 2
</span>
    <span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// Finally add x position to get address
</span>
    <span class="n">LCD_wait</span><span class="p">();</span> <span class="c1">// wait until any previous command finishes
</span>
    <span class="n">LCD_command</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span> <span class="c1">// Send command to LCD
</span>
<span class="p">}</span></code></pre></figure>


        
      </div><!-- /.entry-content -->
    </div><!-- /.entry-wrapper -->
    <nav class="pagination" role="navigation">
      
        <a href="https://grubdragon.github.io/erciitb/tutorials/basic_electronics/" class="btn" title="Basic Electronics">Previous</a>
      
      
        <a href="https://grubdragon.github.io/erciitb/tutorials/arduino/" class="btn" title="Arduino Programming">Next</a>
      
    </nav><!-- /.pagination -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo" class="entry-wrapper">
    

<span>&copy; 2017 Electronics and Robotics Club, IIT Bombay.<!-- Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/so-simple-jekyll-theme/" rel="nofollow">So Simple Theme</a>.--></span>
<div class="social-icons">
	
	<a href="https://facebook.com/erciitb" title="Electronics and Robotics Club, IIT Bombay on Facebook" target="_blank"><i class="fa fa-facebook-square fa-2x"></i></a>
	
	
	
	
	
	<a href="https://github.com/erciitb" title="Electronics and Robotics Club, IIT Bombay on Github" target="_blank"><i class="fa fa-github-square fa-2x"></i></a>
	
  
	
  <a href="https://grubdragon.github.io/erciitb/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss-square fa-2x"></i></a>
</div><!-- /.social-icons -->

  </footer>
</div><!-- /.footer-wrapper -->

<script type="text/javascript">
  var BASE_URL = 'https://grubdragon.github.io/erciitb';
</script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="https://grubdragon.github.io/erciitb/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="https://grubdragon.github.io/erciitb/assets/js/scripts.min.js"></script>




</body>
</html>
